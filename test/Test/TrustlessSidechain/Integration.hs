{-# LANGUAGE NamedFieldPuns #-}
{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}

module Test.TrustlessSidechain.Integration (test) where

import Cardano.Crypto.Wallet qualified as Wallet
import Control.Arrow qualified as Arrow
import Control.Monad qualified as Monad
import Data.ByteString qualified as ByteString
import Data.Functor (void)
import Data.List qualified as List
import Data.Maybe qualified as Maybe
import Data.Text (Text)
import Ledger (getCardanoTxId)
import Ledger.Address (PaymentPubKeyHash (PaymentPubKeyHash, unPaymentPubKeyHash))
import Ledger.Address qualified as Address
import Ledger.Crypto (PubKey, PubKeyHash (PubKeyHash, getPubKeyHash), Signature (getSignature))
import Ledger.Crypto qualified as Crypto
import Plutus.Contract (Contract, awaitTxConfirmed, ownPaymentPubKeyHash)
import Plutus.Contract qualified as Contract
import PlutusTx.Builtins qualified as Builtins
import PlutusTx.Prelude
import Test.Plutip.Contract (assertExecution, initAda, withContract, withContractAs)
import Test.Plutip.Internal.Types qualified as PlutipInternal
import Test.Plutip.LocalCluster (withCluster)
import Test.Plutip.Predicate (shouldFail, shouldSucceed)
import Test.Tasty (TestTree)
import TrustlessSidechain.MerkleTree (RootHash (unRootHash))
import TrustlessSidechain.MerkleTree qualified as MerkleTree
import TrustlessSidechain.OffChain.CommitteeCandidateValidator qualified as CommitteeCandidateValidator
import TrustlessSidechain.OffChain.FUELMintingPolicy qualified as FUELMintingPolicy
import TrustlessSidechain.OffChain.InitSidechain qualified as InitSidechain
import TrustlessSidechain.OffChain.MPTRootTokenMintingPolicy qualified as MPTRootTokenMintingPolicy
import TrustlessSidechain.OffChain.Schema (TrustlessSidechainSchema)
import TrustlessSidechain.OffChain.Types (
  BurnParams (BurnParams),
  DeregisterParams (DeregisterParams),
  InitSidechainParams (
    InitSidechainParams,
    initChainId,
    initCommittee,
    initGenesisHash,
    initMint,
    initUtxo
  ),
  MintParams (MintParams, amount, index, merkleProof, recipient, sidechainEpoch),
  RegisterParams (RegisterParams),
  SaveRootParams (SaveRootParams, committeePubKeys, merkleRoot, signatures, threshold),
  SidechainParams,
  UpdateCommitteeHashParams (UpdateCommitteeHashParams),
 )
import TrustlessSidechain.OffChain.Types qualified as OffChainTypes
import TrustlessSidechain.OffChain.UpdateCommitteeHash qualified as UpdateCommitteeHash
import TrustlessSidechain.OnChain.CommitteeCandidateValidator (
  BlockProducerRegistrationMsg (BlockProducerRegistrationMsg),
  serialiseBprm,
 )
import TrustlessSidechain.OnChain.MPTRootTokenMintingPolicy qualified as MPTRootTokenMintingPolicy
import TrustlessSidechain.OnChain.Types (
  MerkleTreeEntry (MerkleTreeEntry, mteAmount, mteHash, mteIndex, mteRecipient, mteSidechainEpoch),
 )
import TrustlessSidechain.OnChain.UpdateCommitteeHash qualified as UpdateCommitteeHash
import Prelude qualified

-- | The initial committee for intializing the side chain
initCmtPrvKeys :: [Wallet.XPrv]
initCmtPrvKeys = map (Crypto.generateFromSeed' . ByteString.replicate 32) [1 .. 100]

-- | The initial committee for intializing the side chain
initCmtPubKeys :: [PubKey]
initCmtPubKeys = map Crypto.toPublicKey initCmtPrvKeys

-- | 'getSidechainParams' is a helper function to create the 'SidechainParams'
getSidechainParams :: Contract () TrustlessSidechainSchema Text SidechainParams
getSidechainParams = getSidechainParamsWith initCmtPrvKeys

{- | 'getSidechainParamsWith' is a helper function to create the
 'SidechainParams' which allows the specification of the initial committee
-}
getSidechainParamsWith :: [Wallet.XPrv] -> Contract () TrustlessSidechainSchema Text SidechainParams
getSidechainParamsWith cmt =
  InitSidechain.ownTxOutRef >>= \oref ->
    InitSidechain.initSidechain $
      InitSidechainParams
        { initChainId = ""
        , initGenesisHash = ""
        , initUtxo = oref
        , initCommittee = map Crypto.toPublicKey cmt
        , initMint = Nothing
        }

spoPrivKey :: Wallet.XPrv
spoPrivKey = Crypto.generateFromSeed' $ ByteString.replicate 32 123

sidechainPrivKey :: Wallet.XPrv
sidechainPrivKey = Crypto.generateFromSeed' $ ByteString.replicate 32 111

spoPubKey :: PubKey
spoPubKey = Crypto.toPublicKey spoPrivKey

{- | 'saveMerkleRootEntries' is a thin wrapper around
 'MPTRootTokenMintingPolicy.saveRoot' to reduce boilerplate when making tests
 regarding the FUELMintingPolicy.

 To use this, you need to apply the generate the committee first. The
 committee can be generated by the following code:
 > cmtPrvKeys = map (Crypto.generateFromSeed' . ByteString.replicate 32) [1 .. cmtLen]
 > cmtPubKeys = map Crypto.toPublicKey cmtPrvKeys
 > cmt = zip cmtPrvKeys cmtPubKeys
 or as a one liner
 > cmt =  map (id Prelude.&&& Crypto.toPublicKey Prelude.<<< Crypto.generateFromSeed' Prelude.<<< ByteString.replicate 32) [1 .. cmtLen]
-}
saveMerkleRootEntries :: SidechainParams -> [(Wallet.XPrv, PubKey)] -> [MerkleTreeEntry] -> Contract () TrustlessSidechainSchema Text [MintParams]
saveMerkleRootEntries sc cmt entries = do
  -- Create a committee:
  let cmtPrvKeys :: [Wallet.XPrv]
      cmtPubKeys :: [PubKey]

      (cmtPrvKeys, cmtPubKeys) = Prelude.unzip cmt

      cmtLen = Prelude.length cmt

      mt = MerkleTree.fromList $ map MPTRootTokenMintingPolicy.serialiseMte entries
      rh = unRootHash $ MerkleTree.rootHash mt

      mintparams =
        map
          ( \mte ->
              MintParams
                { amount = mteAmount mte
                , recipient = PaymentPubKeyHash $ PubKeyHash $ mteRecipient mte
                , merkleProof = Maybe.fromJust $ MerkleTree.lookupMp (MPTRootTokenMintingPolicy.serialiseMte mte) mt
                , sidechainParams = sc
                , index = mteIndex mte
                , sidechainEpoch = mteSidechainEpoch mte
                , entryHash = mteHash mte
                }
          )
          entries

  MPTRootTokenMintingPolicy.saveRoot
    SaveRootParams
      { sidechainParams = sc
      , merkleRoot = rh
      , signatures = sort $ map (getSignature . Crypto.sign' rh) cmtPrvKeys
      , threshold = (2 * Prelude.fromIntegral cmtLen - 1) `Prelude.div` 3 + 1
      , committeePubKeys = cmtPubKeys
      }
    >>= awaitTxConfirmed . getCardanoTxId

  return mintparams

-- | 'test' is the suite of tests.
test :: TestTree
test =
  withCluster
    "Plutip integration test"
    [ assertExecution
        "InitSidechain.initSidechain"
        (initAda [6, 6])
        ( withContract $ const getSidechainParams
        )
        [shouldSucceed]
    , assertExecution
        "CommitteeCandidateValidator.register"
        (initAda [100] Prelude.<> initAda [1])
        ( withContract $
            const
              ( do
                  sidechainParams <- getSidechainParams
                  oref <- CommitteeCandidateValidator.getInputUtxo
                  let sidechainPubKey = ""
                      msg =
                        serialiseBprm $
                          BlockProducerRegistrationMsg sidechainParams sidechainPubKey oref
                      spoSig = Crypto.sign' msg spoPrivKey
                      sidechainSig = Crypto.sign' msg sidechainPrivKey
                  CommitteeCandidateValidator.register
                    (RegisterParams sidechainParams spoPubKey sidechainPubKey spoSig sidechainSig oref)
              )
        )
        [shouldSucceed]
    , assertExecution
        "CommitteeCandidateValidator.deregister"
        (initAda [100])
        ( withContract $
            const
              ( do
                  sidechainParams <- getSidechainParams
                  oref <- CommitteeCandidateValidator.getInputUtxo
                  let sidechainPubKey = ""
                      msg =
                        serialiseBprm $
                          BlockProducerRegistrationMsg sidechainParams sidechainPubKey oref
                      spoSig = Crypto.sign' msg spoPrivKey
                      sidechainSig = Crypto.sign' msg sidechainPrivKey
                  regTx <-
                    CommitteeCandidateValidator.register
                      (RegisterParams sidechainParams spoPubKey sidechainPubKey spoSig sidechainSig oref)

                  awaitTxConfirmed (getCardanoTxId regTx)

                  deregTx <-
                    CommitteeCandidateValidator.deregister
                      (DeregisterParams sidechainParams spoPubKey)

                  awaitTxConfirmed (getCardanoTxId deregTx)
              )
        )
        [shouldSucceed]
    , assertExecution
        "FUELMintingPolicy.burn"
        (initAda [100, 100, 100, 100])
        ( withContract $
            const $ do
              -- Create a committee:
              let cmt :: [(Wallet.XPrv, PubKey)]
                  cmt = map (id Arrow.&&& Crypto.toPublicKey Arrow.<<< Crypto.generateFromSeed' Arrow.<<< ByteString.replicate 32) [1 .. 10]

              sidechainParams <- getSidechainParamsWith $ map fst cmt

              h <- ownPaymentPubKeyHash

              -- Create the merkle tree / proof
              let mte0 =
                    MerkleTreeEntry
                      { mteIndex = 0
                      , mteAmount = 2
                      , mteRecipient = getPubKeyHash $ unPaymentPubKeyHash h
                      , mteSidechainEpoch = 1
                      , mteHash = "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
                      }

                  mte1 =
                    MerkleTreeEntry
                      { mteIndex = 1
                      , mteAmount = 2
                      , mteRecipient = getPubKeyHash $ unPaymentPubKeyHash h
                      , mteSidechainEpoch = 1
                      , mteHash = "\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001"
                      }

                  mte2 =
                    MerkleTreeEntry
                      { mteIndex = 2
                      , mteAmount = 2
                      , mteRecipient = getPubKeyHash $ unPaymentPubKeyHash h
                      , mteSidechainEpoch = 1
                      , mteHash = "\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\006"
                      }
              mintparams <- saveMerkleRootEntries sidechainParams cmt [mte0, mte1, mte2]

              traverse_ (awaitTxConfirmed . getCardanoTxId Monad.<=< FUELMintingPolicy.mint) mintparams

              FUELMintingPolicy.burn
                BurnParams {amount = -4, recipient = "", sidechainParams}
                >>= awaitTxConfirmed . getCardanoTxId
        )
        [shouldSucceed]
    , assertExecution
        -- we test if we can mint a large amount of transactions on the side chain.
        "FUELMintingPolicy.mint large amounts of tokens"
        (initAda [100, 100, 100])
        ( withContract $
            const $ do
              -- Create a committee:
              let cmt :: [(Wallet.XPrv, PubKey)]
                  cmt = map (id Arrow.&&& Crypto.toPublicKey Arrow.<<< Crypto.generateFromSeed' Arrow.<<< ByteString.replicate 32) [1 .. 10]

              sidechainParams <- getSidechainParamsWith $ map fst cmt

              h <- ownPaymentPubKeyHash
              -- Create the merkle tree / proof
              let mtes = List.take (2 Prelude.^ (16 :: Prelude.Int) :: Prelude.Int) $ List.iterate (\mte -> mte {mteIndex = mteIndex mte + 1, mteHash = Builtins.blake2b_256 (mteHash mte)}) mte0
                  -- 2^16 = 65536
                  mte0 =
                    MerkleTreeEntry
                      { mteIndex = 0
                      , mteAmount = 2
                      , mteRecipient = getPubKeyHash $ unPaymentPubKeyHash h
                      , mteSidechainEpoch = 1
                      , mteHash = "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
                      }

              mintparams <- saveMerkleRootEntries sidechainParams cmt mtes

              traverse_ (awaitTxConfirmed . getCardanoTxId Monad.<=< FUELMintingPolicy.mint) [List.head mintparams]
        )
        [shouldSucceed]
    , assertExecution
        "FUELMintingPolicy oneshot minting policy"
        -- making this test case work is a bit convuluated because sometimes
        -- the constraint solver for building the transaction would spend the
        -- distinguished utxo when saving the root parameters.
        --
        -- Here, we just test if we can mint stuff with the one shot minting
        -- policy
        (initAda [100, 100, 100] Prelude.<> initAda [200, 200, 200]) -- mint, fee, collateral
        ( do
            -- Create a committee:
            let cmt :: [(Wallet.XPrv, PubKey)]
                cmt = map (id Arrow.&&& Crypto.toPublicKey Arrow.<<< Crypto.generateFromSeed' Arrow.<<< ByteString.replicate 32) [1 .. 10]

            -- To make the one shot minting policy work properly, we first make
            -- the 0th wallet give us a distinguished utxo (so we can be sure that this won't
            -- be spent later)
            PlutipInternal.ExecutionResult (Right (utxo, _)) _ _ <- withContractAs 0 $ const $ do CommitteeCandidateValidator.getInputUtxo

            -- Then, we let the second wallet initialize the sidechain... and
            -- do the merkle root signing..
            PlutipInternal.ExecutionResult (Right ((_sidechainParams, mintparams), _)) _ _ <- withContractAs 1 $
              \[pkh0] ->
                InitSidechain.ownTxOutRef >>= \oref -> do
                  sidechainParams <-
                    InitSidechain.initSidechain $
                      InitSidechainParams
                        { initChainId = ""
                        , initGenesisHash = ""
                        , initUtxo = oref
                        , initCommittee = map snd cmt
                        , initMint = Just utxo
                        }

                  -- Create the merkle tree / proof
                  let mte0 =
                        MerkleTreeEntry
                          { mteIndex = 0
                          , mteAmount = 2
                          , mteRecipient = getPubKeyHash $ unPaymentPubKeyHash pkh0
                          , mteSidechainEpoch = 1
                          , mteHash = "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
                          }

                  mintparams <- saveMerkleRootEntries sidechainParams cmt [mte0]

                  return (sidechainParams, mintparams)

            -- Then we let the first wallet (which has the distinguished
            -- genesisMint utxo) claim the tokens.
            withContractAs 0 $
              const $ do
                h <- ownPaymentPubKeyHash

                utxos <- Contract.utxosAt (Address.pubKeyHashAddress h Nothing)
                traverse_ (awaitTxConfirmed . getCardanoTxId Monad.<=< FUELMintingPolicy.mintWithUtxos utxos) mintparams
        )
        [shouldSucceed]
    , assertExecution
        "FUELMintingPolicy oneshot double Mint"
        -- Here, we test the one shot minting policy if it should fail when we
        -- attempt to double mint
        --
        -- Again, there's the same awkwardness in the previous test case for
        -- working with the one shot minting policy...
        (initAda [100, 100, 100] Prelude.<> initAda [200, 200, 200]) -- mint, fee, collateral
        ( do
            -- [beginning of duplciated code from the previous case]
            -- Create a committee:
            let cmt :: [(Wallet.XPrv, PubKey)]
                cmt = map (id Arrow.&&& Crypto.toPublicKey Arrow.<<< Crypto.generateFromSeed' Arrow.<<< ByteString.replicate 32) [1 .. 10]

            -- To make the one shot minting policy work properly, we first make
            -- the 0th wallet give us a distinguished utxo (so we can be sure that this won't
            -- be spent later)
            PlutipInternal.ExecutionResult (Right (utxo, _)) _ _ <- withContractAs 0 $ const $ do CommitteeCandidateValidator.getInputUtxo

            -- Then, we let the second wallet initialize the sidechain... and
            -- do the merkle root signing..
            PlutipInternal.ExecutionResult (Right ((_sidechainParams, mintparams), _)) _ _ <- withContractAs 1 $
              \[pkh0] ->
                InitSidechain.ownTxOutRef >>= \oref -> do
                  sidechainParams <-
                    InitSidechain.initSidechain $
                      InitSidechainParams
                        { initChainId = ""
                        , initGenesisHash = ""
                        , initUtxo = oref
                        , initCommittee = map snd cmt
                        , initMint = Just utxo
                        }

                  -- Create the merkle tree / proof
                  let mte0 =
                        MerkleTreeEntry
                          { mteIndex = 0
                          , mteAmount = 2
                          , mteRecipient = getPubKeyHash $ unPaymentPubKeyHash pkh0
                          , mteSidechainEpoch = 1
                          , mteHash = "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
                          }

                  mintparams <- saveMerkleRootEntries sidechainParams cmt [mte0]

                  return (sidechainParams, mintparams)

            -- Then we let the first wallet (which has the distinguished
            -- genesisMint utxo) claim the tokens.
            withContractAs 0 $
              const $ do
                h <- ownPaymentPubKeyHash

                utxos <- Contract.utxosAt (Address.pubKeyHashAddress h Nothing)
                -- [end of duplciated code from the previous case]
                traverse_ (awaitTxConfirmed . getCardanoTxId Monad.<=< FUELMintingPolicy.mintWithUtxos utxos) mintparams
                traverse_ (awaitTxConfirmed . getCardanoTxId Monad.<=< FUELMintingPolicy.mintWithUtxos utxos) mintparams
                -- note the only thing that is different is that we try to mint twice.
        )
        [shouldFail]
    , assertExecution
        "FUELMintingPolicy.mint"
        -- A basic test which 1) creates the committee, 2) saves a merkle root
        -- with 2 transactions, 3) mints those two transactions that were just
        -- saved.
        (initAda [100, 100, 100, 100]) -- mint, fee
        ( withContract $
            const $ do
              -- Create a committee:
              let cmt :: [(Wallet.XPrv, PubKey)]
                  cmt = map (id Arrow.&&& Crypto.toPublicKey Arrow.<<< Crypto.generateFromSeed' Arrow.<<< ByteString.replicate 32) [1 .. 10]

              sidechainParams <- getSidechainParamsWith $ map fst cmt
              h <- ownPaymentPubKeyHash

              -- Create the merkle tree / proof
              let mte0 =
                    MerkleTreeEntry
                      { mteIndex = 0
                      , mteAmount = 1
                      , mteRecipient = getPubKeyHash $ unPaymentPubKeyHash h
                      , mteSidechainEpoch = 1
                      , mteHash = "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
                      }

                  mte1 =
                    MerkleTreeEntry
                      { mteIndex = 1
                      , mteAmount = 1
                      , mteRecipient = getPubKeyHash $ unPaymentPubKeyHash h
                      , mteSidechainEpoch = 1
                      , mteHash = "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001"
                      }
              mintparams <- saveMerkleRootEntries sidechainParams cmt [mte0, mte1]
              -- Note that redeeming the @mte1@ is actually the worst case
              -- for the distributed set since that will have the most data.

              traverse_ (awaitTxConfirmed . getCardanoTxId Monad.<=< FUELMintingPolicy.mint) mintparams
        )
        [shouldSucceed]
    , assertExecution
        "FUELMintingPolicy.mint double mint"
        (initAda [10, 10, 15]) -- mint, fee
        ( withContract $
            const $ do
              sidechainParams <- getSidechainParams
              h <- ownPaymentPubKeyHash
              -- Create a committee:
              let cmt :: [(Wallet.XPrv, PubKey)]
                  cmt = map (id Arrow.&&& Crypto.toPublicKey Arrow.<<< Crypto.generateFromSeed' Arrow.<<< ByteString.replicate 32) [1 .. 10]
              -- Create the merkle tree / proof
              let mte0 =
                    MerkleTreeEntry
                      { mteIndex = 0
                      , mteAmount = 1
                      , mteRecipient = getPubKeyHash $ unPaymentPubKeyHash h
                      , mteSidechainEpoch = 1
                      , mteHash = "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
                      }

              mintparams <- saveMerkleRootEntries sidechainParams cmt [mte0]

              traverse_ (awaitTxConfirmed . getCardanoTxId Monad.<=< FUELMintingPolicy.mint) mintparams
              traverse_ (awaitTxConfirmed . getCardanoTxId Monad.<=< FUELMintingPolicy.mint) mintparams
        )
        [shouldFail]
    , assertExecution
        "FUELMintingPolicy.mint with wrong committee"
        (initAda [10, 10, 10]) -- mint, fee
        ( withContract $
            const $ do
              -- Create a committee:
              let cmt :: [(Wallet.XPrv, PubKey)]
                  cmt = map (id Arrow.&&& Crypto.toPublicKey Arrow.<<< Crypto.generateFromSeed' Arrow.<<< ByteString.replicate 32) $ map (const 0) [1 :: Integer .. 10]

              sidechainParams <- getSidechainParamsWith $ map fst cmt
              h <- ownPaymentPubKeyHash
              let mte0 =
                    MerkleTreeEntry
                      { mteIndex = 0
                      , mteAmount = 1
                      , mteRecipient = getPubKeyHash $ unPaymentPubKeyHash h
                      , mteSidechainEpoch = 1
                      , mteHash = "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
                      }

                  mte1 =
                    MerkleTreeEntry
                      { mteIndex = 1
                      , mteAmount = 1
                      , mteRecipient = getPubKeyHash $ unPaymentPubKeyHash h
                      , mteSidechainEpoch = 1
                      , mteHash = "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
                      }

              let cmt' :: [(Wallet.XPrv, PubKey)]
                  cmt' = map (id Arrow.&&& Crypto.toPublicKey Arrow.<<< Crypto.generateFromSeed' Arrow.<<< ByteString.replicate 32) [1 .. 10]

              -- this should fail because the curent committee is @cmt@, but we are boldly asserting that the committee should be @cmt'@
              saveMerkleRootEntries sidechainParams cmt' [mte0, mte1]
        )
        [shouldFail]
    , assertExecution
        "FUELMintingPolicy.mint FUEL to other"
        (initAda [100, 100, 101] Prelude.<> initAda [100, 100, 102]) -- mint, fee, ??? <> collateral
        ( do
            -- Create a committee:
            let cmt :: [(Wallet.XPrv, PubKey)]
                cmt = map (id Arrow.&&& Crypto.toPublicKey Arrow.<<< Crypto.generateFromSeed' Arrow.<<< ByteString.replicate 32) [1 .. 10]

            PlutipInternal.ExecutionResult (Right (sidechainParams, _)) _ _ <- withContract $ const $ getSidechainParamsWith $ map fst cmt

            -- let the first wallet @[100,100,101]@ save the root entries, which mints
            -- to someone the second wallet @[100,100,102]@
            PlutipInternal.ExecutionResult (Right (mintparams, _)) _ _ <- withContract $ \[pkh1] -> do
              -- Create the merkle tree / proof
              let mte0 =
                    MerkleTreeEntry
                      { mteIndex = 0
                      , mteAmount = 1
                      , mteRecipient = getPubKeyHash $ unPaymentPubKeyHash pkh1
                      , mteSidechainEpoch = 1
                      , mteHash = "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
                      }
              saveMerkleRootEntries sidechainParams cmt [mte0]

            -- Then, let the second wallet @[100,100,102]@ claim the mint; and burn it immediately
            withContractAs 1 $
              const $ do
                traverse_ (awaitTxConfirmed . getCardanoTxId Monad.<=< FUELMintingPolicy.mint) mintparams
                FUELMintingPolicy.burn
                  BurnParams {amount = -1, recipient = "", sidechainParams}
                  >>= awaitTxConfirmed . getCardanoTxId
        )
        [shouldSucceed]
    , assertExecution
        "FUELMintingPolicy.burn unowned FUEL"
        (initAda [100, 100, 101] Prelude.<> initAda [100, 100, 102])
        ( do
            -- let the first wallet @[100,100,101]@ save the root entries, which mints
            -- to someone the second wallet @[100,100,102]@
            PlutipInternal.ExecutionResult (Right ((sidechainParams, mintparams), _)) _ _ <- withContract $ \[pkh1] -> do
              -- Create a committee:
              let cmt :: [(Wallet.XPrv, PubKey)]
                  cmt = map (id Arrow.&&& Crypto.toPublicKey Arrow.<<< Crypto.generateFromSeed' Arrow.<<< ByteString.replicate 32) [1 .. 10]

              sidechainParams <- getSidechainParamsWith $ map fst cmt

              -- Create the merkle tree / proof
              let mte0 =
                    MerkleTreeEntry
                      { mteIndex = 0
                      , mteAmount = 1
                      , mteRecipient = getPubKeyHash $ unPaymentPubKeyHash pkh1
                      , mteSidechainEpoch = 1
                      , mteHash = "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
                      }
              fmap (sidechainParams,) $ saveMerkleRootEntries sidechainParams cmt [mte0]

            -- Then, let the second wallet @[100,100,102]@ claim the mint
            void $
              withContractAs 1 $
                const $ do
                  traverse (awaitTxConfirmed . getCardanoTxId Monad.<=< FUELMintingPolicy.mint) mintparams

            -- Then, let the first wallet try to burn the second wallet's FUEL
            withContract $
              -- N.B., if it's more clear, this is the same as:
              -- > withContractAs 0 $
              const $ do
                FUELMintingPolicy.burn
                  BurnParams {amount = -1, recipient = "", sidechainParams}
                  >>= awaitTxConfirmed . getCardanoTxId
        )
        [shouldFail]
    , assertExecution
        "UpdateCommitteeHash.updateCommitteeHash on same wallet"
        (initAda [5, 5])
        ( do
            -- Creating the committees:
            let cmtPrvKeys :: [Wallet.XPrv]
                cmtPubKeys :: [PubKey]

                cmtPrvKeys = initCmtPrvKeys
                cmtPubKeys = initCmtPubKeys

            let nCmtPrvKeys :: [Wallet.XPrv]
                nCmtPubKeys :: [PubKey]

                nCmtPrvKeys = map (Crypto.generateFromSeed' . ByteString.replicate 32) [101 .. 200]
                nCmtPubKeys = map Crypto.toPublicKey nCmtPrvKeys

            withContract $ \_ -> do
              sidechainParams <- getSidechainParams

              -- updating the committee hash
              let nCommitteeHash = UpdateCommitteeHash.aggregateKeys nCmtPubKeys
                  sig = UpdateCommitteeHash.multiSign nCommitteeHash cmtPrvKeys

                  uchp =
                    UpdateCommitteeHashParams
                      { OffChainTypes.sidechainParams = sidechainParams
                      , OffChainTypes.newCommitteePubKeys = nCmtPubKeys
                      , OffChainTypes.committeePubKeys = cmtPubKeys
                      , OffChainTypes.committeeSignatures = [sig]
                      }

              UpdateCommitteeHash.updateCommitteeHash uchp
        )
        [shouldSucceed]
    , assertExecution
        "UpdateCommitteeHash.updateCommitteeHash on different wallet"
        (initAda [5, 5] Prelude.<> initAda [5, 5])
        ( do
            -- Creating the committees:
            let cmtPrvKeys :: [Wallet.XPrv]
                cmtPubKeys :: [PubKey]

                cmtPrvKeys = initCmtPrvKeys
                cmtPubKeys = initCmtPubKeys

            let nCmtPrvKeys :: [Wallet.XPrv]
                nCmtPubKeys :: [PubKey]

                nCmtPrvKeys = map (Crypto.generateFromSeed' . ByteString.replicate 32) [101 .. 200]
                nCmtPubKeys = map Crypto.toPublicKey nCmtPrvKeys

            PlutipInternal.ExecutionResult (Right (sidechainParams, _)) _ _ <- withContract $ const getSidechainParams

            withContractAs 1 $ \_ -> do
              -- updating the committee hash
              let nCommitteeHash = UpdateCommitteeHash.aggregateKeys nCmtPubKeys
                  sig = UpdateCommitteeHash.multiSign nCommitteeHash cmtPrvKeys

                  uchp =
                    UpdateCommitteeHashParams
                      { OffChainTypes.sidechainParams = sidechainParams
                      , OffChainTypes.newCommitteePubKeys = nCmtPubKeys
                      , OffChainTypes.committeePubKeys = cmtPubKeys
                      , OffChainTypes.committeeSignatures = [sig]
                      }

              UpdateCommitteeHash.updateCommitteeHash uchp
        )
        [shouldSucceed]
    , assertExecution
        "UpdateCommitteeHash.updateCommitteeHash on same wallet with the wrong committee"
        (initAda [5, 5])
        ( do
            -- Creating the committees:
            let cmtPrvKeys :: [Wallet.XPrv]
                _cmtPubKeys :: [PubKey]

                cmtPrvKeys = initCmtPrvKeys
                _cmtPubKeys = initCmtPubKeys

            let nCmtPrvKeys :: [Wallet.XPrv]
                nCmtPubKeys :: [PubKey]

                nCmtPrvKeys = map (Crypto.generateFromSeed' . ByteString.replicate 32) [101 .. 200]
                nCmtPubKeys = map Crypto.toPublicKey nCmtPrvKeys

            withContract $ \_ -> do
              sidechainParams <- getSidechainParams

              -- updating the committee hash
              let nCommitteeHash = UpdateCommitteeHash.aggregateKeys nCmtPubKeys
                  sig = UpdateCommitteeHash.multiSign nCommitteeHash cmtPrvKeys

                  uchp =
                    UpdateCommitteeHashParams
                      { OffChainTypes.sidechainParams = sidechainParams
                      , OffChainTypes.newCommitteePubKeys = nCmtPubKeys
                      , OffChainTypes.committeePubKeys = nCmtPubKeys
                      , OffChainTypes.committeeSignatures = [sig]
                      }
              UpdateCommitteeHash.updateCommitteeHash uchp
        )
        [shouldFail]
    , assertExecution
        "UpdateCommitteeHash.updateCommitteeHash on different wallet with the wrong committee"
        (initAda [5, 5] Prelude.<> initAda [5, 5])
        ( do
            -- Creating the committees:
            let cmtPrvKeys :: [Wallet.XPrv]
                _cmtPubKeys :: [PubKey]

                cmtPrvKeys = initCmtPrvKeys
                _cmtPubKeys = initCmtPubKeys

            let nCmtPrvKeys :: [Wallet.XPrv]
                nCmtPubKeys :: [PubKey]

                nCmtPrvKeys = map (Crypto.generateFromSeed' . ByteString.replicate 32) [101 .. 200]
                nCmtPubKeys = map Crypto.toPublicKey nCmtPrvKeys

            PlutipInternal.ExecutionResult (Right (sidechainParams, _)) _ _ <- withContract $ const getSidechainParams

            -- Let another wallet update the committee hash.
            withContractAs 1 $ \_ -> do
              let nCommitteeHash = UpdateCommitteeHash.aggregateKeys nCmtPubKeys
                  sig = UpdateCommitteeHash.multiSign nCommitteeHash cmtPrvKeys

                  uchp =
                    UpdateCommitteeHashParams
                      { OffChainTypes.sidechainParams = sidechainParams
                      , newCommitteePubKeys = nCmtPubKeys
                      , committeePubKeys = nCmtPubKeys
                      , committeeSignatures = [sig]
                      }
              UpdateCommitteeHash.updateCommitteeHash uchp
        )
        [shouldFail]
    ]
