strict digraph {
  node [shape=record]
  graph [nodesep="1", ranksep="0.5"];

  subgraph cluster_TxA {
    style=dashed;
    color=lightgrey;
    label="Transaction submitted by sidechain A";

    TxA [ label = "Transaction", shape=diamond ];
    PartialMerkleRootTokenA [ shape=ellipse ];

    TxA -> PartialMerkleRootTokenA [ label = "mints"];
  }

  subgraph cluster_TxB {
    style=dashed;
    color=lightgrey;
    label="Transaction submitted by sidechain B";

    TxB [ label = "Transaction", shape=diamond ];
    PartialMerkleRootTokenB [ shape=ellipse ];

    TxB -> PartialMerkleRootTokenB [ label = "mints"];
  }

  PartialMerkleRootValidator;

  TxA -> PartialMerkleRootValidator [ label = "output" ];
  PartialMerkleRootTokenA -> PartialMerkleRootValidator [ label = "must be paid to", style=dashed];

  TxB -> PartialMerkleRootValidator [ label = "output" ];
  PartialMerkleRootTokenB -> PartialMerkleRootValidator [ label = "must be paid to", style=dashed];

  PartialMerkleRootValidator -> Tx [ label = "input" ];

  PartialMerkleRootValidator -> FinalMerkleRoot
    [ label="
      verifies PartialMerkleRootTokenA
      and PartialMerkleRootTokenB is burnt
      with the same token name"
    , style=dashed
    , dir=back
    ]

  subgraph cluster_Tx {
    style=dashed;
    color=lightgrey;
    label= "Transaction for aggregating PartialMerkleRootTokens"
    labelloc =b;

    Tx;
    FinalMerkleRoot [ shape=ellipse ];
    MerkleRootTokenValidator;

    Tx [ label= "Transaction", shape=diamond ];
    Tx -> FinalMerkleRoot [ label = "mints"]
    Tx -> MerkleRootTokenValidator [ label = "output"]
    FinalMerkleRoot -> MerkleRootTokenValidator [ label = "must be paid to", style=dashed];
  }

}
