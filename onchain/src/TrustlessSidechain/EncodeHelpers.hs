module TrustlessSidechain.EncodeHelpers (
  -- * Helpers for Data encoding

  -- ** ToData
  productToData2,
  productToData3,

  -- ** FromData
  productFromData2,
  productFromData2',
  productFromData3,
  productFromData3',

  -- ** UnsafeFromData
  productUnsafeFromData2,
  productUnsafeFromData3,
) where

import Data.Kind (Type)
import Data.String qualified as HString
import PlutusTx.Builtins (chooseData, matchList)
import PlutusTx.Builtins.Internal qualified as Unsafe
import PlutusTx.Prelude hiding (fromInteger)

{- | Helper to write 'toBuiltinData' for 2-products (something isomorphic to a
pair).

= Notes

This is necessary because, by default, the TH-driven Plutus derivation for a
type such as this:

@
data Foo = Foo Integer Integer
@

Will encode as @Constr 0@. This is inefficient: we only have one \'arm\', and
the tag will always be the same for any valid value, but we have to carry it
around anyway. This function instead encodes it as a list.

It is /essential/ that this only be used together with 'productFromData2' (or
its ticked equivalent) and 'productUnsafeFromData2'; otherwise, the encodings
may not roundtrip.

'productFromData2' will verify that:

* It is given a Plutus list;
* That this list has /exactly/ two elements; and
* Each element of this list decodes to the correct type.

'productUnsafeFromData2' will instead decode without error when:

* It is given a Plutus list;
* That this list has /at least/ two elements; and
* Each element of this list decodes to the correct type.

More precisely, 'productFromData2' verifies that it is given /exactly/ the right
amount of data, whereas 'productUnsafeFromData2' works when it is given /at
least/ the right amount of data (but can be given more). This implies that
if @productFromData2 f dat = Just x@, then @productUnsafeFromData2 f dat = x@,
but that the converse does not necessarily hold. This (arguably unusual)
behaviour matches the definitions generated by the Plutus-provided TH.

= How to use this

@
data Foo = Foo Integer Integer

instance ToData Foo where
  {\-# INLINEABLE toBuiltinData #-\}
  toBuiltinData (Foo x y) = productToData2 x y

instance FromData Foo where
  {\-# INLINEABLE fromBuiltinData #-\}
  fromBuiltinData = productFromData2 Foo

instance UnsafeFromData Foo where
  {\-# INLINEABLE unsafeFromBuiltinData #-\}
  unsafeFromBuiltinData = productUnsafeFromData2 Foo
@
-}
{-# INLINE productToData2 #-}
productToData2 ::
  forall (a :: Type) (b :: Type).
  (ToData a, ToData b) =>
  a ->
  b ->
  BuiltinData
productToData2 x y = Unsafe.mkList go
  where
    go :: Unsafe.BuiltinList BuiltinData
    go = step1 toBuiltinData x (done1 toBuiltinData y)

-- | As 'productToData2', but for 3-products.
{-# INLINE productToData3 #-}
productToData3 ::
  forall (a :: Type) (b :: Type) (c :: Type).
  (ToData a, ToData b, ToData c) =>
  a ->
  b ->
  c ->
  BuiltinData
productToData3 x y z = Unsafe.mkList go
  where
    go :: Unsafe.BuiltinList BuiltinData
    go =
      step1
        toBuiltinData
        x
        ( step1
            toBuiltinData
            y
            ( done1 toBuiltinData z
            )
        )

-- Note from Koz (7/07/23): We disable the 'avoid lambda' hint from HLint for
-- many definitions here, as the cost of function composition makes these
-- routines larger than they would otherwise be, and HLint's suggestions
-- involve use of function composition. In Haskell, this would make perfect
-- sense, but not in Plutus, due to having to pay for it where we'd rather not.

{- | Helper to write 'fromBuiltinData' for 2-products (something isomorphic to a
pair).

= Note

See 'productToData2' for examples of use and why this is necessary.

Use this function if you don't need any verification beyond the components of
the product decoding successfully.
-}
{-# ANN productFromData2 ("HLint: ignore Avoid lambda" :: HString.String) #-}
{-# INLINE productFromData2 #-}
productFromData2 ::
  forall (a :: Type) (b :: Type) (c :: Type).
  (FromData a, FromData b) =>
  (a -> b -> c) ->
  BuiltinData ->
  Maybe c
productFromData2 f = productFromData2' (\x y -> Just (f x y))

{- | As 'productFromData2', but allows additional checks beyond the components
successfully decoding.
-}
{-# ANN productFromData2' ("HLint: ignore Avoid lambda" :: HString.String) #-}
{-# INLINE productFromData2' #-}
productFromData2' ::
  forall (a :: Type) (b :: Type) (c :: Type).
  (FromData a, FromData b) =>
  (a -> b -> Maybe c) ->
  BuiltinData ->
  Maybe c
productFromData2' f dat =
  chooseData
    dat
    (\_ -> Nothing)
    (\_ -> Nothing)
    (\_ -> go (Unsafe.unsafeDataAsList dat))
    (\_ -> Nothing)
    (\_ -> Nothing)
    ()
  where
    go :: Unsafe.BuiltinList BuiltinData -> Maybe c
    go =
      step
        fromBuiltinData
        ( \x ->
            step
              fromBuiltinData
              ( \y ->
                  done (f x y)
              )
        )

-- | As 'productFromData2', but for 3-products.
{-# ANN productFromData3 ("HLint: ignore Avoid lambda" :: HString.String) #-}
{-# INLINE productFromData3 #-}
productFromData3 ::
  forall (a :: Type) (b :: Type) (c :: Type) (d :: Type).
  (FromData a, FromData b, FromData c) =>
  (a -> b -> c -> d) ->
  BuiltinData ->
  Maybe d
productFromData3 f = productFromData3' (\x y z -> Just (f x y z))

{- | As 'productFromData3', but allows additional checks beyond the components
successfully decoding.
-}
{-# ANN productFromData3' ("HLint: ignore Avoid lambda" :: HString.String) #-}
{-# INLINE productFromData3' #-}
productFromData3' ::
  forall (a :: Type) (b :: Type) (c :: Type) (d :: Type).
  (FromData a, FromData b, FromData c) =>
  (a -> b -> c -> Maybe d) ->
  BuiltinData ->
  Maybe d
productFromData3' f dat =
  chooseData
    dat
    (\_ -> Nothing)
    (\_ -> Nothing)
    (\_ -> go (Unsafe.unsafeDataAsList dat))
    (\_ -> Nothing)
    (\_ -> Nothing)
    ()
  where
    go :: Unsafe.BuiltinList BuiltinData -> Maybe d
    go =
      step
        fromBuiltinData
        ( \x ->
            step
              fromBuiltinData
              ( \y ->
                  step
                    fromBuiltinData
                    ( \z ->
                        done (f x y z)
                    )
              )
        )

{- | Helper to write 'unsafeFromBuiltinData' for 2-products (something
isomorphic to a pair).

= Note

See 'productToData2' for examples of use, and why this is necessary.
-}
{-# ANN productUnsafeFromData2 ("HLint: ignore Avoid lambda" :: HString.String) #-}
{-# INLINE productUnsafeFromData2 #-}
productUnsafeFromData2 ::
  forall (a :: Type) (b :: Type) (c :: Type).
  (UnsafeFromData a, UnsafeFromData b) =>
  (a -> b -> c) ->
  BuiltinData ->
  c
productUnsafeFromData2 f dat =
  step'
    unsafeFromBuiltinData
    ( \x ->
        done' unsafeFromBuiltinData (f x)
    )
    (Unsafe.unsafeDataAsList dat)

-- | As 'productUnsafeFromData2', but for 3-products.
{-# ANN productUnsafeFromData3 ("HLint: ignore Avoid lambda" :: HString.String) #-}
{-# INLINE productUnsafeFromData3 #-}
productUnsafeFromData3 ::
  forall (a :: Type) (b :: Type) (c :: Type) (d :: Type).
  (UnsafeFromData a, UnsafeFromData b, UnsafeFromData c) =>
  (a -> b -> c -> d) ->
  BuiltinData ->
  d
productUnsafeFromData3 f dat =
  step'
    unsafeFromBuiltinData
    ( \x ->
        step'
          unsafeFromBuiltinData
          ( \y ->
              done' unsafeFromBuiltinData (f x y)
          )
    )
    (Unsafe.unsafeDataAsList dat)

-- Helpers

step ::
  forall (k :: Type) (r :: Type).
  (BuiltinData -> Maybe k) ->
  (k -> Unsafe.BuiltinList BuiltinData -> Maybe r) ->
  Unsafe.BuiltinList BuiltinData ->
  Maybe r
step f cb ell = matchList ell (\_ -> Nothing) \x xs ->
  case f x of
    Nothing -> Nothing
    Just x' -> cb x' xs

step' ::
  forall (k :: Type) (r :: Type).
  (BuiltinData -> k) ->
  (k -> Unsafe.BuiltinList BuiltinData -> r) ->
  Unsafe.BuiltinList BuiltinData ->
  r
step' f cb ell =
  let x = f (Unsafe.head ell)
      ell' = Unsafe.tail ell
   in cb x ell'

step1 ::
  forall (k :: Type).
  (k -> BuiltinData) ->
  k ->
  Unsafe.BuiltinList BuiltinData ->
  Unsafe.BuiltinList BuiltinData
step1 f x = Unsafe.mkCons (f x)

done ::
  forall (d :: Type).
  Maybe d ->
  Unsafe.BuiltinList BuiltinData ->
  Maybe d
done res ell = matchList ell (\_ -> res) (\_ _ -> Nothing)

done' ::
  forall (k :: Type) (r :: Type).
  (BuiltinData -> k) ->
  (k -> r) ->
  Unsafe.BuiltinList BuiltinData ->
  r
done' f g ell = g (f (Unsafe.head ell))

done1 ::
  forall (k :: Type).
  (k -> BuiltinData) ->
  k ->
  Unsafe.BuiltinList BuiltinData
done1 f x = Unsafe.mkCons (f x) (Unsafe.mkNilData Unsafe.unitval)
